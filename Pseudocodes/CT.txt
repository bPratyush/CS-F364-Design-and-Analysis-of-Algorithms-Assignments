procedure CLIQUE;
    procedure UPDATE(i,C);
        begin
            if i=n+1
                then print out a new clique C 
                else
                    begin
1:                      if C-N(i) not empty then UPDATE(i+1,C);
                            {prepare for tests}
                                {compute T[y]=|N(y) intersection C intersection N(i)} for y belonging to V - C - {i}}
2:                      for each vertex x belonging to C intersection N(i)
                            do for each vertex y belonging  N(x)-C-{i}
                                do T[y]:=T[y]+1
                            {compute S[y]=|N(y) intersection (C-N(i))| for y belonging V-C}
3:                      for each vertex x belonging C-N(i)
                            do for each vertex x belonging N(x)-C 
                                do S[y]:=S[y]+1;
                            FLAG:=true
                        {maximality test}
4:                      if there exists vertex y belonging N(i)-C such that y<i and T[y]=|C intersection N(i)| 
                            then FLAG:=false; {(C intersection N(i)) union {i} is not a clique of Gi}
                        {lexico test}
5:                      sort all vertices in C-N(i) in ascending order j1<j2<...<jp where p=|C-N(i)|;\
                        {case S(y)>=1 see Lemma 6}
6:                      for k:=1 to p
                            do for each vertex y belonging to N(jk)-C such that y<i and T[y]=|C intersection N(i)|
                                do if y>=jk
                                    then S[y]:=S[y]-1 {alter S[y] to S(y)}
                                    else 
                                        if (jk is the first vertex which satisfies y<jk)
                                            then {S[y]=S(y)}
                                                if (S[y]+k-1=p) and (y>=jk-1) {j0=0}
                                                    then FLAG:=false; {C is not lexico largest}
                        {case S(y)=0}
7:                      if(C intersection N(i) not empty)
                            then for each vertex y not belonging to C union {i} such that y<i, T[y]=|C intersection N(i)| and S[y]=0
                            {access y from the adjacency list of a vertex in C intersection N(i)}
                                    do if jp < y then FLAG:=false; {C is not lexico largest}
                                    else if jp < i-1 then FLAG:=false; {C is not lexico largest}
                            {reinitialise S and T}
8:                      for each vertex x belonging C intersection N(i)
                            do for each vertex y belonging N(x)-C-{i}
                                do T[y]:=0;
9:                      for each vertex x belonging C - N(i)
                            do for each vertex y belonging N(x)-C
                                do S[y]:=0;
                        {FLAG is true iff (C intersection N(i)) union {i} is clique of Gi and C is lexicographically largest clique of Gi-1 containing C intersection N(i)}
10:                     if FLAG 
                            then
                                begin
                                    SAVE := C - N(i);
                                    C:= (C intersection N(i)) union {i};
                                    UPDATE(i+1,C);
                                    C:=(C-{i}) union SAVE
                                end
                            end
                        end;
                        begin {of CLIQUE}  
                            number the vertices of given graph G in such a way that d(1)<=d(2)<=....<=d(n);
                            for i:=1 to n {initialise S and T}
                                do begin S[i]:=0 and T[i]:=0 end;
                            C:={1}
                            UPDATE(2,C)
                    end {of CLIQUE};                     
